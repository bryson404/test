-- ============================================
-- KIRITO SOFTWORKS TRANSPARENT REMOTE DISK v6.0
-- Makes remote JBOD appear as the ONLY disk on this computer
-- All files go to server, nothing stored locally
-- ============================================

local RDISK = {
    version = "6.0",
    serverId = nil,
    modemSide = nil,
    connected = false,
    cache = {}, -- Temporary cache for open files
    mountPoint = "/" -- Root mount (takes over entire filesystem)
}

-- ============================================
-- MODEM SETUP
-- ============================================

function RDISK:openModem()
    local sides = {"top", "bottom", "left", "right", "front", "back"}
    for _, side in ipairs(sides) do
        if peripheral.getType(side) == "modem" then
            self.modemSide = side
            rednet.open(side)
            return true
        end
    end
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            self.modemSide = name
            rednet.open(name)
            return true
        end
    end
    return false
end

function RDISK:findServer()
    print("Searching for JBOD server...")
    rednet.broadcast({ action = "discover" }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg, protocol = os.pullEvent()
        if event == "rednet_message" and protocol == "jbod" and msg and msg.server then
            print("Found server at computer " .. id)
            self.serverId = id
            return true
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function RDISK:connect(serverId)
    self.serverId = serverId
    self.connected = true
    return true
end

-- ============================================
-- REMOTE FILESYSTEM API
-- ============================================

function RDISK:remoteList(path)
    if not self.connected then return nil end
    rednet.send(self.serverId, { action = "list", path = path }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.files
        elseif event == "timer" and id == timer then
            return nil
        end
    end
end

function RDISK:remoteExists(path)
    if not self.connected then return false end
    rednet.send(self.serverId, { action = "exists", path = path }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.exists
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function RDISK:remoteIsDir(path)
    if not self.connected then return false end
    rednet.send(self.serverId, { action = "isdir", path = path }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.isdir
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function RDISK:remoteGetSize(path)
    if not self.connected then return 0 end
    rednet.send(self.serverId, { action = "getsize", path = path }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.size or 0
        elseif event == "timer" and id == timer then
            return 0
        end
    end
end

function RDISK:remoteRead(path)
    if not self.connected then return nil end
    rednet.send(self.serverId, { action = "read", path = path }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.data
        elseif event == "timer" and id == timer then
            return nil
        end
    end
end

function RDISK:remoteWrite(path, data)
    if not self.connected then return false end
    rednet.send(self.serverId, { action = "write", path = path, data = data }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.success
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function RDISK:remoteDelete(path)
    if not self.connected then return false end
    rednet.send(self.serverId, { action = "delete", path = path }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.success
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function RDISK:remoteMakeDir(path)
    if not self.connected then return false end
    rednet.send(self.serverId, { action = "mkdir", path = path }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.success
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function RDISK:remoteStats()
    if not self.connected then return nil end
    rednet.send(self.serverId, { action = "stats" }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == self.serverId then
            return msg.stats
        elseif event == "timer" and id == timer then
            return nil
        end
    end
end

-- ============================================
-- FS API OVERRIDE - Intercept all file calls
-- ============================================

RDISK.originalFS = {}

function RDISK:installFSHook()
    -- Save originals
    self.originalFS.list = fs.list
    self.originalFS.exists = fs.exists
    self.originalFS.isDir = fs.isDir
    self.originalFS.getSize = fs.getSize
    self.originalFS.open = fs.open
    self.originalFS.delete = fs.delete
    self.originalFS.makeDir = fs.makeDir
    self.originalFS.getFreeSpace = fs.getFreeSpace
    self.originalFS.getCapacity = fs.getCapacity
    
    -- Override fs.list
    fs.list = function(path)
        path = path or "/"
        -- Always return remote list
        local files = RDISK:remoteList(path)
        if files then
            return files
        end
        return {}
    end
    
    -- Override fs.exists
    fs.exists = function(path)
        -- Block access to local directories except critical ones
        if path:match("^/rom") or path:match("^/disk") then
            return self.originalFS.exists(path)
        end
        return RDISK:remoteExists(path)
    end
    
    -- Override fs.isDir
    fs.isDir = function(path)
        if path:match("^/rom") or path:match("^/disk") then
            return self.originalFS.isDir(path)
        end
        return RDISK:remoteIsDir(path)
    end
    
    -- Override fs.getSize
    fs.getSize = function(path)
        if path:match("^/rom") or path:match("^/disk") then
            return self.originalFS.getSize(path)
        end
        return RDISK:remoteGetSize(path)
    end
    
    -- Override fs.open - CRITICAL: Redirect to remote
    fs.open = function(path, mode)
        -- Allow local access to ROM and disk drives
        if path:match("^/rom") or path:match("^/disk") then
            return self.originalFS.open(path, mode)
        end
        
        -- Everything else goes to remote
        mode = mode or "r"
        
        if mode == "r" or mode == "rb" then
            -- Read from remote
            local data = RDISK:remoteRead(path)
            if not data then return nil end
            
            -- Return fake file handle
            local pos = 1
            return {
                readAll = function()
                    return data
                end,
                readLine = function()
                    if pos > #data then return nil end
                    local lineEnd = data:find("\n", pos) or #data + 1
                    local line = data:sub(pos, lineEnd - 1)
                    pos = lineEnd + 1
                    return line
                end,
                close = function() end
            }
            
        elseif mode == "w" or mode == "wb" or mode == "a" or mode == "ab" then
            -- Write/Append to remote - buffer locally then send
            local buffer = {}
            if mode == "a" or mode == "ab" then
                -- Append - read existing first
                local existing = RDISK:remoteRead(path)
                if existing then
                    table.insert(buffer, existing)
                end
            end
            
            return {
                write = function(self, text)
                    table.insert(buffer, text)
                end,
                writeLine = function(self, text)
                    table.insert(buffer, text)
                    table.insert(buffer, "\n")
                end,
                flush = function()
                    local data = table.concat(buffer)
                    RDISK:remoteWrite(path, data)
                end,
                close = function()
                    local data = table.concat(buffer)
                    RDISK:remoteWrite(path, data)
                end
            }
        end
        
        return nil
    end
    
    -- Override fs.delete
    fs.delete = function(path)
        if path:match("^/rom") or path:match("^/disk") then
            return self.originalFS.delete(path)
        end
        return RDISK:remoteDelete(path)
    end
    
    -- Override fs.makeDir
    fs.makeDir = function(path)
        if path:match("^/rom") or path:match("^/disk") then
            return self.originalFS.makeDir(path)
        end
        return RDISK:remoteMakeDir(path)
    end
    
    -- Override fs.getFreeSpace - Show remote free space
    fs.getFreeSpace = function(path)
        local stats = RDISK:remoteStats()
        if stats then
            return stats.free
        end
        return 0
    end
    
    -- Override fs.getCapacity - Show remote total
    fs.getCapacity = function(path)
        local stats = RDISK:remoteStats()
        if stats then
            return stats.total
        end
        return 0
    end
    
    print("Filesystem hooked - all operations now go to remote server")
end

function RDISK:uninstallFSHook()
    -- Restore originals
    fs.list = self.originalFS.list
    fs.exists = self.originalFS.exists
    fs.isDir = self.originalFS.isDir
    fs.getSize = self.originalFS.getSize
    fs.open = self.originalFS.open
    fs.delete = self.originalFS.delete
    fs.makeDir = self.originalFS.makeDir
    fs.getFreeSpace = self.originalFS.getFreeSpace
    if self.originalFS.getCapacity then
        fs.getCapacity = self.originalFS.getCapacity
    end
end

-- ============================================
-- DISPLAY
-- ============================================

function RDISK:formatBytes(b)
    if b >= 1000000000 then return string.format("%.2f GB", b/1000000000)
    elseif b >= 1000000 then return string.format("%.1f MB", b/1000000)
    elseif b >= 1000 then return string.format("%.1f KB", b/1000)
    else return b .. " B" end
end

function RDISK:drawBar(percent, width)
    width = width or 10
    local filled = math.floor((percent / 100) * width)
    filled = math.max(0, math.min(filled, width))
    return string.rep("*", filled) .. string.rep("=", width - filled)
end

function RDISK:displayStorage()
    local stats = self:remoteStats()
    if not stats then
        print("Storage: Not connected")
        return
    end
    
    local totalStr = self:formatBytes(stats.total)
    local bar = self:drawBar(stats.percent, 10)
    
    print(totalStr)
    print("[" .. bar .. "]" .. stats.percent .. "% full")
end

-- ============================================
-- SHELL LOCKDOWN - Prevent local access
-- ============================================

function RDISK:lockdownShell()
    -- Change directory to root (which is now remote)
    shell.setDir("/")
    
    -- Override shell commands that might access local files
    local oldRun = shell.run
    shell.run = function(command, ...)
        -- Block dangerous commands
        if command == "cd" then
            local args = {...}
            if args[1] and (args[1]:match("^/rom") or args[1]:match("^/disk")) then
                print("Access denied: " .. args[1])
                return false
            end
        end
        return oldRun(command, ...)
    end
    
    -- Set prompt to show remote status
    shell.setPrompt("remote> ")
end

-- ============================================
-- MAIN INTERFACE
-- ============================================

function RDISK:mainMenu()
    while true do
        term.clear()
        term.setCursorPos(1,1)
        
        print("===================================================")
        print("  KIRITO SOFTWORKS REMOTE DISK v" .. self.version)
        print("===================================================")
        print()
        
        if self.connected then
            print("Status: CONNECTED to server " .. self.serverId)
            print()
            self:displayStorage()
            print()
            print("All file operations now go to REMOTE storage")
            print("Local disk is HIDDEN")
            print()
            print("1. Enter remote shell")
            print("2. Disconnect and exit")
            print()
            write("Choice: ")
            local choice = read()
            
            if choice == "1" then
                self:enterRemoteShell()
            elseif choice == "2" then
                self:uninstallFSHook()
                print("Disconnected. Local filesystem restored.")
                break
            end
        else
            print("Status: NOT CONNECTED")
            print()
            print("1. Auto-discover server")
            print("2. Manual connect")
            print("3. Exit")
            print()
            write("Choice: ")
            local choice = read()
            
            if choice == "1" then
                if self:findServer() then
                    self.connected = true
                    self:installFSHook()
                end
            elseif choice == "2" then
                write("Server ID: ")
                local id = tonumber(read())
                if id then
                    self:connect(id)
                    self.connected = true
                    self:installFSHook()
                end
            elseif choice == "3" then
                break
            end
        end
    end
end

function RDISK:enterRemoteShell()
    term.clear()
    term.setCursorPos(1,1)
    
    print("===================================================")
    print("  REMOTE DISK SHELL")
    print("  All files stored on SERVER " .. self.serverId)
    print("===================================================")
    print()
    print("Type 'exit' to return to menu")
    print()
    
    -- Apply lockdown
    self:lockdownShell()
    
    -- Start shell
    shell.run("shell")
    
    -- Restore prompt
    shell.setPrompt("> ")
end

-- ============================================
-- MAIN
-- ============================================

function main()
    term.clear()
    term.setCursorPos(1,1)
    
    print("===================================================")
    print("  KIRITO SOFTWORKS REMOTE DISK v" .. RDISK.version)
    print("  Transparent Remote Storage Client")
    print("===================================================")
    print()
    
    if not RDISK:openModem() then
        print("ERROR: No modem found!")
        return
    end
    
    print("Modem ready")
    print()
    
    RDISK:mainMenu()
    
    term.clear()
    term.setCursorPos(1,1)
    print("Goodbye!")
end

main()
