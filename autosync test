-- ============================================
-- KIRITO SOFTWORKS JBOD BACKGROUND DAEMON v4.4
-- Runs continuously in background, auto-syncs everything
-- Start with: jbod_daemon start
-- Stop with:  jbod_daemon stop
-- ============================================

local args = {...}
local command = args[1] or "start"

-- Daemon control file
local DAEMON_FILE = "/.jbod_daemon_running"
local LOG_FILE = "/jbod_daemon.log"
local SYNC_FOLDER = "/sync"
local SERVER_ID = nil
local MODEM_SIDE = nil
local running = false

-- ============================================
-- LOGGING
-- ============================================

function log(msg)
    local time = os.date("%H:%M:%S")
    local line = "[" .. time .. "] " .. msg
    print(line)
    
    -- Append to log file
    local h = fs.open(LOG_FILE, "a")
    if h then
        h.writeLine(line)
        h.close()
    end
end

-- ============================================
-- MODEM & CONNECTION
-- ============================================

function openModem()
    local sides = {"top", "bottom", "left", "right", "front", "back"}
    for _, side in ipairs(sides) do
        if peripheral.getType(side) == "modem" then
            MODEM_SIDE = side
            rednet.open(side)
            log("Modem opened on " .. side)
            return true
        end
    end
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            MODEM_SIDE = name
            rednet.open(name)
            log("Modem opened: " .. name)
            return true
        end
    end
    return false
end

function findServer()
    log("Searching for JBOD server...")
    rednet.broadcast({ action = "discover" }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg, protocol = os.pullEvent()
        if event == "rednet_message" and protocol == "jbod" and msg and msg.server then
            log("Found server at computer " .. id)
            SERVER_ID = id
            return true
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

-- ============================================
-- SERVER OPERATIONS
-- ============================================

function serverList()
    if not SERVER_ID then return nil end
    rednet.send(SERVER_ID, { action = "list" }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == SERVER_ID then
            return msg.files or {}
        elseif event == "timer" and id == timer then
            return nil
        end
    end
end

function serverRead(filename)
    if not SERVER_ID then return nil end
    rednet.send(SERVER_ID, { action = "read", file = filename }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == SERVER_ID then
            return msg.data
        elseif event == "timer" and id == timer then
            return nil
        end
    end
end

function serverWrite(filename, data)
    if not SERVER_ID then return false end
    rednet.send(SERVER_ID, { action = "write", file = filename, data = data }, "jbod")
    
    local timer = os.startTimer(5)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == SERVER_ID then
            return msg.success
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

function serverDelete(filename)
    if not SERVER_ID then return false end
    rednet.send(SERVER_ID, { action = "delete", file = filename }, "jbod")
    
    local timer = os.startTimer(3)
    while true do
        local event, id, msg = os.pullEvent()
        if event == "rednet_message" and id == SERVER_ID then
            return msg.success
        elseif event == "timer" and id == timer then
            return false
        end
    end
end

-- ============================================
-- SYNC LOGIC
-- ============================================

function getLocalFiles()
    local files = {}
    if not fs.isDir(SYNC_FOLDER) then return files end
    
    for _, name in ipairs(fs.list(SYNC_FOLDER)) do
        local path = SYNC_FOLDER .. "/" .. name
        if not fs.isDir(path) then
            local h = fs.open(path, "r")
            local data = h.readAll()
            h.close()
            files[name] = {
                data = data,
                size = #data,
                hash = #data -- Simple hash = size
            }
        end
    end
    return files
end

function fullSync()
    log("Starting full sync...")
    
    -- Ensure folders exist
    if not fs.exists(SYNC_FOLDER) then
        fs.makeDir(SYNC_FOLDER)
        log("Created sync folder: " .. SYNC_FOLDER)
    end
    
    local localFiles = getLocalFiles()
    local serverFiles = serverList() or {}
    
    -- Build lookups
    local serverLookup = {}
    for _, name in ipairs(serverFiles) do
        serverLookup[name] = true
    end
    
    local localLookup = {}
    for name, info in pairs(localFiles) do
        localLookup[name] = info
    end
    
    local uploads = 0
    local downloads = 0
    local deletes = 0
    
    -- 1. Upload local files that don't exist on server
    for name, info in pairs(localFiles) do
        if not serverLookup[name] then
            log("UPLOAD: " .. name .. " (" .. info.size .. " bytes)")
            if serverWrite(name, info.data) then
                uploads = uploads + 1
            else
                log("  FAILED to upload " .. name)
            end
        end
    end
    
    -- 2. Download server files that don't exist locally
    for _, name in ipairs(serverFiles) do
        if not localLookup[name] then
            log("DOWNLOAD: " .. name)
            local data = serverRead(name)
            if data then
                local h = fs.open(SYNC_FOLDER .. "/" .. name, "w")
                h.write(data)
                h.close()
                downloads = downloads + 1
            else
                log("  FAILED to download " .. name)
            end
        end
    end
    
    log("Sync complete: " .. uploads .. " up, " .. downloads .. " down")
    return uploads, downloads
end

function watchAndSync()
    log("Starting watch mode...")
    local lastFiles = getLocalFiles()
    
    while running do
        sleep(2) -- Check every 2 seconds
        
        if not running then break end
        
        local currentFiles = getLocalFiles()
        local serverFiles = serverList() or {}
        local serverLookup = {}
        for _, name in ipairs(serverFiles) do
            serverLookup[name] = true
        end
        
        -- Check for new/modified local files -> Upload
        for name, info in pairs(currentFiles) do
            if not lastFiles[name] then
                -- New file
                log("AUTO-UPLOAD (new): " .. name)
                serverWrite(name, info.data)
            elseif lastFiles[name].hash ~= info.hash then
                -- Modified file
                log("AUTO-UPLOAD (modified): " .. name)
                serverWrite(name, info.data)
            end
        end
        
        -- Check for deleted local files -> Delete from server
        for name, info in pairs(lastFiles) do
            if not currentFiles[name] then
                log("AUTO-DELETE: " .. name)
                serverDelete(name)
            end
        end
        
        -- Check for new server files -> Download
        for _, name in ipairs(serverFiles) do
            if not currentFiles[name] and not lastFiles[name] then
                log("AUTO-DOWNLOAD: " .. name)
                local data = serverRead(name)
                if data then
                    local h = fs.open(SYNC_FOLDER .. "/" .. name, "w")
                    h.write(data)
                    h.close()
                end
            end
        end
        
        lastFiles = currentFiles
    end
end

-- ============================================
-- DAEMON CONTROL
-- ============================================

function startDaemon()
    -- Check if already running
    if fs.exists(DAEMON_FILE) then
        print("Daemon already running!")
        print("Use 'jbod_daemon stop' to stop it first")
        return
    end
    
    -- Create control file
    local h = fs.open(DAEMON_FILE, "w")
    h.writeLine(tostring(os.getComputerID()))
    h.close()
    
    log("===================================================")
    log("KIRITO SOFTWORKS JBOD DAEMON STARTING")
    log("===================================================")
    
    -- Open modem
    if not openModem() then
        log("ERROR: No modem found!")
        fs.delete(DAEMON_FILE)
        return
    end
    
    -- Find server
    if not findServer() then
        log("ERROR: Could not find JBOD server!")
        log("Make sure server is running and in range")
        fs.delete(DAEMON_FILE)
        return
    end
    
    -- Initial sync
    fullSync()
    
    -- Start watching
    running = true
    log("Daemon running. Monitoring: " .. SYNC_FOLDER)
    log("Press 'Q' in this window to stop")
    
    -- Run sync in parallel with user input
    parallel.waitForAny(
        function() watchAndSync() end,
        function()
            while running do
                local event, key = os.pullEvent("key")
                if key == keys.q then
                    log("Stop requested")
                    running = false
                end
            end
        end
    )
    
    -- Cleanup
    fs.delete(DAEMON_FILE)
    log("Daemon stopped")
end

function stopDaemon()
    if not fs.exists(DAEMON_FILE) then
        print("Daemon not running")
        return
    end
    
    -- Read the computer ID that started it
    local h = fs.open(DAEMON_FILE, "r")
    local id = h.readLine()
    h.close()
    
    if tonumber(id) == os.getComputerID() then
        -- We started it, but we can't easily stop it from outside
        -- Just delete the file and tell user to press Q
        fs.delete(DAEMON_FILE)
        print("Daemon stop signal sent")
        print("Press 'Q' in the daemon window to fully stop")
    else
        print("Daemon started by different computer: " .. id)
    end
end

function statusDaemon()
    if fs.exists(DAEMON_FILE) then
        local h = fs.open(DAEMON_FILE, "r")
        local id = h.readLine()
        h.close()
        print("Daemon is RUNNING (started by computer " .. id .. ")")
        print("Sync folder: " .. SYNC_FOLDER)
        if fs.exists(LOG_FILE) then
            print("Recent log:")
            -- Show last 10 lines
            local h2 = fs.open(LOG_FILE, "r")
            local lines = {}
            local line = h2.readLine()
            while line do
                table.insert(lines, line)
                line = h2.readLine()
            end
            h2.close()
            for i = math.max(1, #lines-9), #lines do
                print("  " .. lines[i])
            end
        end
    else
        print("Daemon is NOT running")
    end
end

-- ============================================
-- MAIN
-- ============================================

if command == "start" then
    startDaemon()
elseif command == "stop" then
    stopDaemon()
elseif command == "status" then
    statusDaemon()
elseif command == "once" then
    -- One-time sync without daemon
    log("One-time sync...")
    if openModem() and findServer() then
        fullSync()
    end
else
    print("Usage: jbod_daemon [start|stop|status|once]")
    print("  start  - Start background daemon")
    print("  stop   - Stop daemon")
    print("  status - Check if running")
    print("  once   - One-time sync")
end
