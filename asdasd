-- ============================================
-- KIRITO SOFTWORKS NFS SERVER v5.0
-- Network File System - Run files directly from server!
-- No local downloading needed
-- ============================================

local JBOD = {
    version = "5.0",
    drives = {},
    clients = {}, -- Track connected clients
    accessLog = {}
}

-- ============================================
-- MODEM SETUP
-- ============================================

function JBOD:openModem()
    local sides = {"top", "bottom", "left", "right", "front", "back"}
    for _, side in ipairs(sides) do
        if peripheral.getType(side) == "modem" then
            rednet.open(side)
            print("Modem opened on " .. side)
            return true
        end
    end
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            rednet.open(name)
            print("Modem opened: " .. name)
            return true
        end
    end
    return false
end

-- ============================================
-- DRIVE DETECTION
-- ============================================

JBOD.VALID_TYPES = {
    "drive", "disk_drive", "diskraid", "disk_raid",
    "advanced_disk_raid", "advanceddiskraid",
}

function JBOD:isValidStorageType(pType)
    if not pType then return false end
    pType = pType:lower()
    for _, v in ipairs(self.VALID_TYPES) do
        if pType:find(v) then return true end
    end
    return false
end

function JBOD:scanDrives()
    self.drives = {}
    
    for _, name in ipairs(peripheral.getNames()) do
        local pType = peripheral.getType(name)
        
        if self:isValidStorageType(pType) then
            local drive = peripheral.wrap(name)
            local isRaid = pType:find("raid") ~= nil
            local hasMedia = isRaid
            
            if not isRaid and drive.isDiskPresent then
                local ok, result = pcall(function() return drive.isDiskPresent() end)
                hasMedia = ok and result
            end
            
            if hasMedia then
                local mountPath = nil
                if drive.getMountPath then
                    local ok, mp = pcall(function() return drive.getMountPath() end)
                    if ok then mountPath = mp end
                end
                if not mountPath then mountPath = name end
                
                table.insert(self.drives, {
                    name = name,
                    peripheral = drive,
                    pType = pType,
                    mountPath = mountPath,
                    fullPath = "/" .. mountPath,
                    isRaid = isRaid
                })
            end
        end
    end
    
    table.sort(self.drives, function(a,b) return a.name < b.name end)
    return #self.drives
end

-- ============================================
-- FILE OPERATIONS
-- ============================================

function JBOD:getDriveFiles(driveIndex)
    local drive = self.drives[driveIndex]
    local files = {}
    local p = drive.peripheral
    
    if drive.isRaid and p.getDisk then
        for slot = 1, 9 do
            local ok, disk = pcall(function() return p.getDisk(slot) end)
            if ok and disk and disk.getMountPath then
                local ok2, mp = pcall(function() return disk.getMountPath() end)
                if ok2 and mp then
                    local path = "/" .. mp
                    if fs.isDir(path) then
                        for _, fname in ipairs(fs.list(path)) do
                            local fpath = path .. "/" .. fname
                            if not fs.isDir(fpath) then
                                table.insert(files, {
                                    name = fname,
                                    size = fs.getSize(fpath),
                                    drive = driveIndex,
                                    slot = slot,
                                    path = fpath
                                })
                            end
                        end
                    end
                end
            end
        end
    elseif drive.fullPath and fs.isDir(drive.fullPath) then
        for _, fname in ipairs(fs.list(drive.fullPath)) do
            local fpath = drive.fullPath .. "/" .. fname
            if not fs.isDir(fpath) then
                table.insert(files, {
                    name = fname,
                    size = fs.getSize(fpath),
                    drive = driveIndex,
                    path = fpath
                })
            end
        end
    end
    
    return files
end

function JBOD:findFile(filename)
    for i = 1, #self.drives do
        local files = self:getDriveFiles(i)
        for _, f in ipairs(files) do
            if f.name == filename then return f end
        end
    end
    return nil
end

function JBOD:readFile(filename)
    local file = self:findFile(filename)
    if not file then return nil end
    
    local h = fs.open(file.path, "r")
    if not h then return nil end
    local data = h.readAll()
    h.close()
    return data
end

function JBOD:writeFile(filename, data)
    -- Find drive with most space
    local bestDrive = nil
    local bestFree = -1
    
    for i, drive in ipairs(self.drives) do
        local free = 0
        if drive.isRaid and drive.peripheral.getDisk then
            for slot = 1, 9 do
                local ok, disk = pcall(function() return drive.peripheral.getDisk(slot) end)
                if ok and disk and disk.getMountPath then
                    local ok2, mp = pcall(function() return disk.getMountPath() end)
                    if ok2 and mp then
                        free = free + fs.getFreeSpace("/" .. mp)
                    end
                end
            end
        elseif drive.fullPath then
            free = fs.getFreeSpace(drive.fullPath)
        end
        
        if free > bestFree then
            bestFree = free
            bestDrive = i
        end
    end
    
    if not bestDrive or bestFree < #data then return false, "No space" end
    
    local drive = self.drives[bestDrive]
    
    if drive.isRaid and drive.peripheral.getDisk then
        for slot = 1, 9 do
            local ok, disk = pcall(function() return drive.peripheral.getDisk(slot) end)
            if ok and disk and disk.getMountPath then
                local ok2, mp = pcall(function() return disk.getMountPath() end)
                if ok2 and mp then
                    local path = "/" .. mp .. "/" .. filename
                    local h = fs.open(path, "w")
                    if h then
                        h.write(data)
                        h.close()
                        return true
                    end
                end
            end
        end
    else
        local path = drive.fullPath .. "/" .. filename
        local h = fs.open(path, "w")
        if h then
            h.write(data)
            h.close()
            return true
        end
    end
    
    return false, "Write failed"
end

function JBOD:deleteFile(filename)
    local file = self:findFile(filename)
    if not file then return false end
    fs.delete(file.path)
    return true
end

function JBOD:listAllFiles()
    local all = {}
    for i = 1, #self.drives do
        local files = self:getDriveFiles(i)
        for _, f in ipairs(files) do
            table.insert(all, f.name)
        end
    end
    return all
end

-- ============================================
-- REMOTE EXECUTION SUPPORT
-- ============================================

function JBOD:executeFile(filename, clientId, args)
    -- Read the file
    local data = self:readFile(filename)
    if not data then return false, "File not found" end
    
    -- Check if it's a Lua program
    if not filename:match("%.lua$") then
        return false, "Not a Lua file"
    end
    
    -- Log execution
    table.insert(self.accessLog, {
        time = os.time(),
        client = clientId,
        file = filename,
        action = "execute"
    })
    
    -- Return the code for client to run
    return true, data
end

-- ============================================
-- NETWORK PROTOCOL
-- ============================================

function JBOD:handleRequest()
    print("NFS Server ready! Computer ID: " .. os.getComputerID())
    print("Waiting for clients...")
    
    while true do
        local event, id, msg, protocol = os.pullEvent("rednet_message")
        
        if protocol == "jbod" and msg and msg.action then
            -- Track client
            self.clients[id] = os.time()
            
            -- DISCOVERY
            if msg.action == "discover" then
                rednet.send(id, { 
                    server = true, 
                    version = self.version,
                    id = os.getComputerID()
                }, "jbod")
                
            -- LIST FILES
            elseif msg.action == "list" then
                local files = self:listAllFiles()
                rednet.send(id, { files = files }, "jbod")
                
            -- READ FILE (for viewing/editing)
            elseif msg.action == "read" and msg.file then
                local data = self:readFile(msg.file)
                rednet.send(id, { 
                    data = data,
                    found = data ~= nil
                }, "jbod")
                
            -- WRITE FILE
            elseif msg.action == "write" and msg.file and msg.data then
                local ok, err = self:writeFile(msg.file, msg.data)
                rednet.send(id, { success = ok, error = err }, "jbod")
                
            -- DELETE FILE
            elseif msg.action == "delete" and msg.file then
                local ok = self:deleteFile(msg.file)
                rednet.send(id, { success = ok }, "jbod")
                
            -- REMOTE EXECUTE - Run file on client without downloading
            elseif msg.action == "execute" and msg.file then
                local ok, codeOrErr = self:executeFile(msg.file, id, msg.args)
                rednet.send(id, { 
                    success = ok, 
                    code = ok and codeOrErr or nil,
                    error = not ok and codeOrErr or nil
                }, "jbod")
                
            -- STREAM EXECUTE - For large files, stream in chunks
            elseif msg.action == "stream_start" and msg.file then
                local data = self:readFile(msg.file)
                if data then
                    -- Send in chunks of 1000 chars
                    local chunkSize = 1000
                    local chunks = math.ceil(#data / chunkSize)
                    
                    rednet.send(id, { 
                        stream = true,
                        chunks = chunks,
                        size = #data
                    }, "jbod")
                    
                    for i = 1, chunks do
                        local start = (i-1) * chunkSize + 1
                        local chunk = data:sub(start, start + chunkSize - 1)
                        rednet.send(id, {
                            stream_chunk = i,
                            data = chunk
                        }, "jbod")
                        sleep(0.05) -- Prevent overflow
                    end
                    
                    rednet.send(id, { stream_end = true }, "jbod")
                else
                    rednet.send(id, { error = "File not found" }, "jbod")
                end
            end
        end
    end
end

-- ============================================
-- MAIN
-- ============================================

function main()
    print("===================================================")
    print("  KIRITO SOFTWORKS NFS SERVER v" .. JBOD.version)
    print("  Network File System - Remote Execution Enabled")
    print("===================================================")
    print()
    
    if not JBOD:openModem() then
        print("ERROR: No modem found!")
        return
    end
    
    print("Scanning drives...")
    local count = JBOD:scanDrives()
    print("Found " .. count .. " drives")
    print()
    
    JBOD:handleRequest()
end

main()
